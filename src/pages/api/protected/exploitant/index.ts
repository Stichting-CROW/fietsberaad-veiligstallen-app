import type { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "~/server/db";
import { type VSContactExploitant, exploitantSelect } from "~/types/contacts";
import { getServerSession } from "next-auth";
import { authOptions } from '~/pages/api/auth/[...nextauth]'
import { exploitantCreateSchema } from "~/types/database";
import { generateID, validateUserSession } from "~/utils/server/database-tools";

export type ExploitantenResponse = {
  data?: VSContactExploitant[];
  error?: string;
};

export default async function handle(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getServerSession(req, res, authOptions);
  const validationResult = await validateUserSession(session);
  
  if ('error' in validationResult) {
    res.status(validationResult.status).json({exploitanten: []});
    return;
  }

  const { sites, userId } = validationResult;

  switch (req.method) {
    case "GET": {
      // GET all exploitant organizations user can access
      const exploitanten = (await prisma.contacts.findMany({
        where: {
          ItemType: "exploitant",
          // ID: { in: sites }
        },
        select: exploitantSelect
      })) as unknown as VSContactExploitant[];
      res.status(200).json(exploitanten);
      break;
    }
    case "POST": {
      try {
        const newID = generateID();
        const data = { ...req.body, ID: newID };

        const validationResult = exploitantCreateSchema.safeParse(data);
        if (!validationResult.success) {
          console.error("Validation error:", validationResult.error);
          res.status(400).json({ error: validationResult.error.errors });
          return;
        }
        const parsed = validationResult.data;
        
        const newData = {
          ID: newID,
          Helpdesk: parsed.Helpdesk ?? undefined,
          ItemType: "exploitant",
          CompanyName: parsed.CompanyName,
          Status: "1", // Default status
          UrlName: parsed.UrlName ?? undefined,
          ParentID: parsed.ParentID ?? undefined,
        }

        const newOrg = await prisma.contacts.create({data: newData, select: exploitantSelect}) as unknown as VSContactExploitant;
        if(!newOrg) {
          console.error("Error creating new exploitant:", newData);
          res.status(500).json({error: "Error creating new exploitant"});
          return;
        }
        // add a record to the security_users_sites table that links the new organization to the user's sites
        const newLink = await prisma.security_users_sites.create({
          data: {
            UserID: userId,
            SiteID: newOrg.ID
          }
        });
        if(!newLink) {
          console.error("Error creating link to new exploitant:", newOrg.ID);
          res.status(500).json({error: "Error creating link to new exploitant"});
          return;
        }

        res.status(201).json({ data: [newOrg]});
      } catch (e) {
        console.error("Error creating exploitant:", e);
        res.status(500).json({ error: "Error creating exploitant" });
      }
      break;
    }
    default: {
      res.status(405).end({ error: "Method Not Allowed" }); // Method Not Allowed
    }
  }
} 